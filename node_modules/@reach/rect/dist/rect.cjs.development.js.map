{"version":3,"file":"rect.cjs.development.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reacttraining.com/reach-ui/rect\n * @see Source                https://github.com/reach/reach-ui/tree/master/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  children(args: { rect: PRect | null; ref: React.Ref<any> }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends HTMLElement = HTMLElement>(\n  nodeRef: React.RefObject<T>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let initialRectSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let observerRef = useRef<any>(null);\n  useIsomorphicLayoutEffect(() => {\n    const cleanup = () => {\n      observerRef.current && observerRef.current.unobserve();\n    };\n\n    if (!nodeRef.current) {\n      console.warn(\"You need to place the ref\");\n      return cleanup;\n    }\n\n    if (!observerRef.current) {\n      observerRef.current = observeRect(nodeRef.current, (rect: DOMRect) => {\n        onChange && onChange(rect);\n        setRect(rect);\n      });\n    }\n\n    if (!initialRectSet.current) {\n      initialRectSet.current = true;\n      setRect(nodeRef.current.getBoundingClientRect());\n    }\n\n    observe && observerRef.current.observe();\n    return cleanup;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [observe, onChange]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PartialRect = Partial<PRect>;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n"],"names":["Rect","onChange","observe","children","ref","useRef","rect","useRect","displayName","propTypes","PropTypes","func","isRequired","bool","nodeRef","initialRectSet","useState","setRect","observerRef","useIsomorphicLayoutEffect","cleanup","current","unobserve","console","warn","observeRect","getBoundingClientRect"],"mappings":";;;;;;;;;;;AAAA;;;;;;;;;;AAiBA;;;;;;IAKaA,IAAI,GAAwB,SAA5BA,IAA4B;MACvCC,gBAAAA;0BACAC;MAAAA,oCAAU;MACVC,gBAAAA;AAEA,MAAMC,GAAG,GAAGC,YAAM,CAAqB,IAArB,CAAlB;AACA,MAAMC,IAAI,GAAGC,OAAO,CAACH,GAAD,EAAMF,OAAN,EAAeD,QAAf,CAApB;AACA,SAAOE,QAAQ,CAAC;AAAEC,IAAAA,GAAG,EAAHA,GAAF;AAAOE,IAAAA,IAAI,EAAJA;AAAP,GAAD,CAAf;AACD;;AAwCY;AACXN,EAAAA,IAAI,CAACQ,WAAL,GAAmB,MAAnB;AACAR,EAAAA,IAAI,CAACS,SAAL,GAAiB;AACfN,IAAAA,QAAQ,EAAEO,SAAS,CAACC,IAAV,CAAeC,UADV;AAEfV,IAAAA,OAAO,EAAEQ,SAAS,CAACG,IAFJ;AAGfZ,IAAAA,QAAQ,EAAES,SAAS,CAACC;AAHL,GAAjB;AAKD;;AAID;;;;;;;;;SAOgBJ,QACdO,SACAZ,SACAD;MADAC;AAAAA,IAAAA,UAAmB;;;AAGnB,MAAIa,cAAc,GAAGV,YAAM,CAAC,KAAD,CAA3B;;kBACsBW,cAAQ,CAAiB,IAAjB;MAAzBV;MAAMW;;AACX,MAAIC,WAAW,GAAGb,YAAM,CAAM,IAAN,CAAxB;AACAc,EAAAA,+BAAyB,CAAC;AACxB,QAAMC,OAAO,GAAG,SAAVA,OAAU;AACdF,MAAAA,WAAW,CAACG,OAAZ,IAAuBH,WAAW,CAACG,OAAZ,CAAoBC,SAApB,EAAvB;AACD,KAFD;;AAIA,QAAI,CAACR,OAAO,CAACO,OAAb,EAAsB;AACpBE,MAAAA,OAAO,CAACC,IAAR,CAAa,2BAAb;AACA,aAAOJ,OAAP;AACD;;AAED,QAAI,CAACF,WAAW,CAACG,OAAjB,EAA0B;AACxBH,MAAAA,WAAW,CAACG,OAAZ,GAAsBI,WAAW,CAACX,OAAO,CAACO,OAAT,EAAkB,UAACf,IAAD;AACjDL,QAAAA,QAAQ,IAAIA,QAAQ,CAACK,IAAD,CAApB;AACAW,QAAAA,OAAO,CAACX,IAAD,CAAP;AACD,OAHgC,CAAjC;AAID;;AAED,QAAI,CAACS,cAAc,CAACM,OAApB,EAA6B;AAC3BN,MAAAA,cAAc,CAACM,OAAf,GAAyB,IAAzB;AACAJ,MAAAA,OAAO,CAACH,OAAO,CAACO,OAAR,CAAgBK,qBAAhB,EAAD,CAAP;AACD;;AAEDxB,IAAAA,OAAO,IAAIgB,WAAW,CAACG,OAAZ,CAAoBnB,OAApB,EAAX;AACA,WAAOkB,OAAP;AAED,GAzBwB,EAyBtB,CAAClB,OAAD,EAAUD,QAAV,CAzBsB,CAAzB;AA2BA,SAAOK,IAAP;AACD;;;;;;"}