{"version":3,"file":"rect.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/rect!\n *\n * Measures DOM elements (aka. bounding client rect).\n *\n * @see getBoundingClientRect https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n * @see Docs                  https://reacttraining.com/reach-ui/rect\n * @see Source                https://github.com/reach/reach-ui/tree/master/packages/rect\n */\n\nimport React, { useRef, useState } from \"react\";\nimport PropTypes from \"prop-types\";\nimport observeRect from \"@reach/observe-rect\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Rect\n *\n * @param props\n */\nexport const Rect: React.FC<RectProps> = ({\n  onChange,\n  observe = true,\n  children,\n}) => {\n  const ref = useRef<HTMLElement | null>(null);\n  const rect = useRect(ref, observe, onChange);\n  return children({ ref, rect });\n};\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/rect#rect-props\n */\nexport type RectProps = {\n  /**\n   * Tells `Rect` to observe the position of the node or not. While observing,\n   * the `children` render prop may call back very quickly (especially while\n   * scrolling) so it can be important for performance to avoid observing when\n   * you don't need to.\n   *\n   * This is typically used for elements that pop over other elements (like a\n   * dropdown menu), so you don't need to observe all the time, only when the\n   * popup is active.\n   *\n   * Pass `true` to observe, `false` to ignore.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-observe\n   */\n  observe?: boolean;\n  /**\n   * Calls back whenever the `rect` of the element changes.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  onChange?: (rect: PRect) => void;\n  /**\n   * A function that calls back to you with a `ref` to place on an element and\n   * the `rect` measurements of the dom node.\n   *\n   * **Note**: On the first render `rect` will be `undefined` because we can't\n   * measure a node that has not yet been rendered. Make sure your code accounts\n   * for this.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/rect#rect-onchange\n   */\n  children(args: { rect: PRect | null; ref: React.Ref<any> }): JSX.Element;\n};\n\nif (__DEV__) {\n  Rect.displayName = \"Rect\";\n  Rect.propTypes = {\n    children: PropTypes.func.isRequired,\n    observe: PropTypes.bool,\n    onChange: PropTypes.func,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useRect\n *\n * @param nodeRef\n * @param observe\n * @param onChange\n */\nexport function useRect<T extends HTMLElement = HTMLElement>(\n  nodeRef: React.RefObject<T>,\n  observe: boolean = true,\n  onChange?: (rect: DOMRect) => void\n): null | DOMRect {\n  let initialRectSet = useRef(false);\n  let [rect, setRect] = useState<DOMRect | null>(null);\n  let observerRef = useRef<any>(null);\n  useIsomorphicLayoutEffect(() => {\n    const cleanup = () => {\n      observerRef.current && observerRef.current.unobserve();\n    };\n\n    if (!nodeRef.current) {\n      console.warn(\"You need to place the ref\");\n      return cleanup;\n    }\n\n    if (!observerRef.current) {\n      observerRef.current = observeRect(nodeRef.current, (rect: DOMRect) => {\n        onChange && onChange(rect);\n        setRect(rect);\n      });\n    }\n\n    if (!initialRectSet.current) {\n      initialRectSet.current = true;\n      setRect(nodeRef.current.getBoundingClientRect());\n    }\n\n    observe && observerRef.current.observe();\n    return cleanup;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [observe, onChange]);\n\n  return rect;\n}\n\nexport default Rect;\n\nexport type PartialRect = Partial<PRect>;\n\nexport type PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n"],"names":["Rect","onChange","observe","children","ref","useRef","rect","useRect","nodeRef","initialRectSet","useState","setRect","observerRef","useIsomorphicLayoutEffect","cleanup","current","unobserve","observeRect","getBoundingClientRect","console","warn"],"mappings":"qOAsBaA,EAA4B,gBACvCC,IAAAA,aACAC,QAAAA,gBACAC,IAAAA,SAEMC,EAAMC,SAA2B,aAEhCF,EAAS,CAAEC,IAAAA,EAAKE,KADVC,EAAQH,EAAKF,EAASD,eA4DrBM,EACdC,EACAN,EACAD,YADAC,IAAAA,GAAmB,OAGfO,EAAiBJ,UAAO,KACNK,WAAyB,MAA1CJ,OAAMK,OACPC,EAAcP,SAAY,aAC9BQ,6BAA0B,eAClBC,EAAU,WACdF,EAAYG,SAAWH,EAAYG,QAAQC,oBAGxCR,EAAQO,SAKRH,EAAYG,UACfH,EAAYG,QAAUE,EAAYT,EAAQO,SAAS,SAACT,GAClDL,GAAYA,EAASK,GACrBK,EAAQL,OAIPG,EAAeM,UAClBN,EAAeM,SAAU,EACzBJ,EAAQH,EAAQO,QAAQG,0BAG1BhB,GAAWU,EAAYG,QAAQb,UACxBY,IAjBLK,QAAQC,KAAK,6BACNN,KAkBR,CAACZ,EAASD,IAENK"}